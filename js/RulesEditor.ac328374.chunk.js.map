{"version":3,"sources":["components/AutoComplete/AutoCompleteMenuItem.tsx","components/AutoComplete/AutoCompleteList.tsx","components/AutoComplete/AutoComplete.tsx","features/RulesBuilder/RulesEditor/RulesEditor.tsx","features/RulesBuilder/RulesEditor/useAutoComplete.tsx","features/RulesBuilder/RulesEditorContainer/RulesEditorContainer.tsx"],"names":["StyledItem","styled","ListItem","isHighlighted","theme","css","colors","success","white","PropertyType","Box","props","type","warning","getTypeColor","DescriptionText","Text","base","isAvailableProperty","property","undefined","AutoCompleteMenuItem","item","index","useMenuContext","getItemProps","highlightedIndex","propertyText","alias","propertyType","key","name","Grid","gridTemplateColumns","pr","mt","fontSize","description","StyledList","List","top","left","AutoCompleteMenuList","memo","rest","ref","getMenuProps","data-testid","AutoComplete","properties","position","Portal","map","i","itemToString","StyledEditable","SyntaxHighlightEditable","hasErrors","danger","baseLight","radii","shadows","focusLight","minHeight","RulesEditor","autoCompleteItems","filteredProperties","initialValue","editor","autoCompleteTarget","onChange","renderLeaf","useState","children","text","value","setValue","autoCompletePosition","setAutoCompletePosition","getInputProps","isOpen","toggleMenu","clearSelection","useFormikContext","setFieldValue","getFieldProps","readOnly","useRulesEditor","useEffect","length","rect","ReactEditor","toDOMRange","getBoundingClientRect","bottom","window","pageYOffset","pageXOffset","handleChange","useCallback","n","Node","string","join","spellCheck","tokensToSkip","tokenize","renderElement","attributes","useAutoComplete","char","searchInput","setSearchInput","target","setTarget","isTriggerCharImmediatelyBeforeStart","start","before","Editor","unit","distance","beforeRange","range","charText","expression","RegExp","prefix","buildTriggerCharBeforeExpression","match","point","input","isEnclosingCharImmediatelyAfterStart","after","afterRange","suffix","buildEnclosingCharAfterExpression","hasWordsBeforeStart","beforeText","buildHasWordsBeforeStartExpression","beforeMatch","hasWordsAfterStart","afterText","buildHasWordsAfterStartExpression","afterMatch","afterMatchWithEnclosing","selection","Range","isCollapsed","edges","triggerCharPoint","enclosingCharPoint","middleBefore","middleAfter","combinedRange","insertProperty","Transforms","insertText","move","isList","RulesEditorContainer","submitAndTestCount","useRulesBuilder","availableProperties","availableLists","listAutocomplete","propertyAutocomplete","useField","meta","error","filterItems","items","filter","toLowerCase","includes","useMemo","getLeafRenderer","useSyntaxHighlighting","initialSelectedItem","select"],"mappings":"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","file":"static/js/RulesEditor.ac328374.chunk.js","sourcesContent":["import React from 'react';\nimport styled, { css } from 'styled-components';\nimport { ListItem, Text, Box } from '@cko/primitives';\nimport { useMenuContext, TTheme } from '@cko/primitives';\nimport Grid from 'components/Grid';\nimport { AutoCompleteProperty, AvailableProperty } from 'types/models';\n\ninterface ListItemProps {\n  isHighlighted: boolean;\n}\n\nconst getStateStyle = ({\n  isHighlighted,\n  theme,\n}: ListItemProps & { theme: TTheme }) => {\n  if (isHighlighted) {\n    return css`\n      background-color: ${theme.colors.success};\n      color: ${theme.colors.white};\n    `;\n  }\n\n  return css`\n    background-color: transparent;\n  `;\n};\n\nconst getTypeColor = (type: string, theme: TTheme) => {\n  switch (type) {\n    case 'string':\n      return css`\n        color: ${theme.colors.success};\n      `;\n    case 'number':\n      return css`\n        color: ${theme.colors.warning};\n      `;\n  }\n};\n\nconst StyledItem = styled(ListItem)<ListItemProps>`\n  font-size: 14px;\n  background-color: #fff;\n  cursor: pointer;\n  list-style: none;\n  padding: 12px 8px;\n  ${getStateStyle};\n`;\n\nconst PropertyType = styled(Box)<ListItemProps & { type: string }>`\n  font-family: OCR A Extended;\n  justify-self: end;\n  font-size: 12px;\n  ${(props) => {\n    return props.isHighlighted\n      ? props.theme.colors.white\n      : getTypeColor(props.type, props.theme);\n  }};\n`;\n\nconst DescriptionText = styled(Text)<ListItemProps>`\n  font-size: 14px;\n  color: ${({ isHighlighted, theme }) =>\n    isHighlighted ? theme.colors.white : theme.colors.base};\n`;\n\ninterface MenuItemProps {\n  item: AutoCompleteProperty;\n  index: number;\n  itemToString?: (item: AutoCompleteProperty) => string;\n}\n\nexport const isAvailableProperty = (\n  property: AutoCompleteProperty\n): property is AvailableProperty => {\n  return (property as AvailableProperty).type !== undefined;\n};\n\nconst AutoCompleteMenuItem: React.FunctionComponent<MenuItemProps> = ({\n  item,\n  index,\n}) => {\n  const { getItemProps, highlightedIndex } = useMenuContext();\n  const isHighlighted = highlightedIndex === index;\n  const propertyText = isAvailableProperty(item) ? item.type : item.alias;\n  const propertyType = isAvailableProperty(item) ? item.type : '';\n\n  return (\n    <StyledItem\n      {...getItemProps({\n        key: item.name,\n        index,\n        item,\n      })}\n      isHighlighted={isHighlighted}\n    >\n      <Grid gridTemplateColumns=\"auto auto\">\n        <Box pr={3}>{item.name}</Box>\n        <PropertyType type={propertyType} isHighlighted={isHighlighted}>\n          {propertyText}\n        </PropertyType>\n      </Grid>\n      <DescriptionText isHighlighted={isHighlighted} mt={2} fontSize=\"12px\">\n        {item.description}\n      </DescriptionText>\n    </StyledItem>\n  );\n};\n\nexport default AutoCompleteMenuItem;\n","import React, { memo } from 'react';\nimport styled from 'styled-components';\nimport { List, useMenuContext } from '@cko/primitives';\n\nconst StyledList = styled(List)<{ top: number; left: number }>`\n  box-shadow: rgba(121, 131, 149, 0.15) 0px 1px 3px 0px;\n  border: 1px solid rgb(223, 231, 235);\n  top: ${(props) => props.top}px;\n  left: ${(props) => props.left}px;\n  position: absolute;\n  z-index: 10000;\n  background: white;\n  max-height: 300px;\n  box-shadow: rgba(121, 131, 149, 0.15) 0px 1px 3px 0px;\n  overflow-y: scroll;\n  max-width: 400px;\n  min-width: 300px;\n`;\n\nconst AutoCompleteMenuList: React.FC<{ top: number; left: number }> = memo(\n  ({ ...rest }) => {\n    const { ref, getMenuProps } = useMenuContext();\n\n    return (\n      <div ref={ref} data-testid=\"menu-list\" {...getMenuProps()}>\n        <StyledList {...rest} />\n      </div>\n    );\n  }\n);\n\nexport default AutoCompleteMenuList;\n","import React from 'react';\nimport Portal from 'components/Portal';\nimport AutoCompleteMenuItem from './AutoCompleteMenuItem';\nimport AutoCompleteMenuList from './AutoCompleteList';\nimport { AutoCompleteProperty } from 'types/models';\n\ninterface Props {\n  properties: AutoCompleteProperty[];\n  position: [number, number];\n}\n\nconst AutoComplete: React.FunctionComponent<Props> = ({\n  properties,\n  position,\n}) => {\n  const [top, left] = position;\n\n  return (\n    <Portal>\n      <AutoCompleteMenuList top={top} left={left}>\n        {properties.map((property, i) => (\n          <AutoCompleteMenuItem\n            item={property}\n            index={i}\n            itemToString={(item) => item.name}\n            key={property.name}\n          />\n        ))}\n      </AutoCompleteMenuList>\n    </Portal>\n  );\n};\n\nexport default AutoComplete;\n","import React, { useState, useCallback, useEffect } from 'react';\nimport { Editor, Node, Range } from 'slate';\nimport { Slate, ReactEditor } from 'slate-react';\nimport styled, { css } from 'styled-components';\nimport { tokenize } from './antlrUtils';\nimport { useFormikContext } from 'formik';\nimport {\n  EditableProps,\n  RenderElementProps,\n  RenderLeafProps,\n} from 'slate-react/dist/components/editable';\nimport SyntaxHighlightEditable from './SyntaxHighlightEditable';\nimport AutoComplete from 'components/AutoComplete';\nimport { useMenuContext } from '@cko/primitives';\nimport { AvailableProperty, ListSummary } from 'types/models';\nimport { minHeight, MinHeightProps } from 'styled-system';\nimport { useRulesEditor } from '../RulesEditorContext';\n\nconst StyledEditable = styled(SyntaxHighlightEditable)<\n  EditableProps & { hasErrors: boolean } & MinHeightProps\n>(\n  ({ theme, hasErrors }) => css`\n    overflow: auto;\n    padding: 8px 12px;\n    line-height: 2em;\n    border: 1px solid\n      ${hasErrors ? theme.colors.danger : theme.colors.baseLight};\n    border-radius: ${theme.radii[1]};\n    box-shadow: ${theme.shadows.focusLight[0]};\n    :focus {\n      box-shadow: 0 0 0 4px rgba(13, 165, 220, 0.5),\n        0 2px 5px 0 rgba(27, 47, 55, 0.25);\n    }\n\n    ${minHeight}\n  `\n);\n\nconst serialize = (nodes: Node[]) => {\n  return nodes.map((n) => Node.string(n)).join('\\n');\n};\n\ninterface Props {\n  autoCompleteItems: (AvailableProperty | ListSummary)[];\n  initialValue: string;\n  name: string;\n  editor: Editor & ReactEditor;\n  autoCompleteTarget: Range | null;\n  onChange: () => void;\n  renderLeaf: (props: RenderLeafProps) => JSX.Element;\n  hasErrors: boolean;\n}\n\nconst RulesEditor: React.FunctionComponent<Props> = ({\n  autoCompleteItems: filteredProperties,\n  initialValue,\n  name,\n  editor,\n  autoCompleteTarget,\n  onChange,\n  renderLeaf,\n  hasErrors,\n}) => {\n  const [value, setValue] = useState<Node[]>([\n    {\n      children: [{ text: initialValue }],\n    },\n  ]);\n\n  const [autoCompletePosition, setAutoCompletePosition] = useState<\n    [number, number]\n  >([0, 0]);\n\n  const {\n    getInputProps,\n    isOpen,\n    toggleMenu,\n    clearSelection,\n  } = useMenuContext();\n\n  const { setFieldValue, getFieldProps } = useFormikContext<any>();\n\n  const { readOnly } = useRulesEditor();\n\n  useEffect(() => {\n    if (autoCompleteTarget && filteredProperties.length > 0) {\n      const domRange = ReactEditor.toDOMRange(editor, autoCompleteTarget);\n      const rect = domRange.getBoundingClientRect();\n      setAutoCompletePosition([\n        rect.bottom + window.pageYOffset + 10,\n        rect.left + window.pageXOffset,\n      ]);\n      toggleMenu({ isOpen: true });\n    } else {\n      toggleMenu({ isOpen: false });\n    }\n  }, [editor, autoCompleteTarget, filteredProperties.length, toggleMenu]);\n\n  const handleChange = useCallback(\n    (value) => {\n      setValue(value);\n      setFieldValue(name, serialize(value));\n      onChange();\n      clearSelection();\n    },\n    [clearSelection, name, onChange, setFieldValue]\n  );\n\n  return (\n    <>\n      <Slate editor={editor} value={value} onChange={handleChange}>\n        <StyledEditable\n          readOnly={readOnly}\n          spellCheck=\"false\"\n          data-testid=\"rules-editor\"\n          tokensToSkip={['OTHERS', 'WHITESPACE']}\n          tokenize={tokenize}\n          hasErrors={hasErrors}\n          renderElement={(props: RenderElementProps) => {\n            const { attributes, children } = props;\n\n            return <p {...attributes}>{children}</p>;\n          }}\n          renderLeaf={renderLeaf}\n          {...getFieldProps(name)}\n          {...(isOpen ? getInputProps() : {})}\n          minHeight={['200px', '200px', '200px', '350px']}\n        />\n        {isOpen && (\n          <AutoComplete\n            properties={filteredProperties}\n            position={autoCompletePosition}\n          />\n        )}\n      </Slate>\n    </>\n  );\n};\n\nexport default RulesEditor;\n","import { useCallback, useState } from 'react';\nimport { Editor, Location, Range } from 'slate';\n\nexport interface TriggerChar {\n  prefix: string;\n  suffix?: string;\n}\n\nconst buildTriggerCharBeforeExpression = (char: TriggerChar) =>\n  new RegExp(`\\\\B${char.prefix}$`);\n\nconst buildEnclosingCharAfterExpression = (char: TriggerChar) =>\n  new RegExp(`^${char.suffix}\\\\B`);\n\nconst buildHasWordsBeforeStartExpression = (char: TriggerChar) =>\n  new RegExp(`${char.prefix}([a-zA-Z_0-9]+)$`);\n\nconst buildHasWordsAfterStartExpression = (char: TriggerChar) =>\n  new RegExp(`^([a-zA-Z_0-9]*)${char.suffix}`);\n\nconst useAutoComplete = (editor: Editor, char: TriggerChar) => {\n  const [searchInput, setSearchInput] = useState('');\n  const [target, setTarget] = useState<Range | null>(null);\n\n  const isTriggerCharImmediatelyBeforeStart = useCallback(\n    (start: Location) => {\n      const before = Editor.before(editor, start, {\n        unit: 'offset',\n        distance: 2,\n      });\n      const beforeRange = before && Editor.range(editor, before, start);\n      const charText = beforeRange && Editor.string(editor, beforeRange);\n\n      const expression = buildTriggerCharBeforeExpression(char);\n      const match = charText?.match(expression);\n\n      if (!match) {\n        return null;\n      }\n\n      const point = Editor.before(editor, start, {\n        unit: 'offset',\n        distance: match[0].length,\n      });\n\n      return {\n        point,\n        range: point && Editor.range(editor, point, start),\n        input: match[1],\n      };\n    },\n    [char, editor]\n  );\n\n  const isEnclosingCharImmediatelyAfterStart = useCallback(\n    (start: Location) => {\n      const after = Editor.after(editor, start, {\n        unit: 'offset',\n        distance: 2,\n      });\n      const afterRange = after && Editor.range(editor, start, after);\n      const charText = afterRange && Editor.string(editor, afterRange);\n\n      const expression = char.suffix && buildEnclosingCharAfterExpression(char);\n      const match = expression && charText?.match(expression);\n\n      if (!match) {\n        return null;\n      }\n\n      const point = Editor.after(editor, start, {\n        unit: 'offset',\n        distance: match[0].length,\n      });\n\n      return {\n        point,\n        range: point && Editor.range(editor, start, point),\n        input: match[1],\n      };\n    },\n    [char, editor]\n  );\n\n  const hasWordsBeforeStart = useCallback(\n    (start: Location) => {\n      const before = Editor.before(editor, start, { unit: 'line' });\n      const beforeRange = before && Editor.range(editor, before, start);\n      const beforeText = beforeRange && Editor.string(editor, beforeRange);\n\n      const expression = buildHasWordsBeforeStartExpression(char);\n      const beforeMatch = beforeText?.match(expression);\n\n      if (!beforeMatch) {\n        return null;\n      }\n      const point = Editor.before(editor, start, {\n        unit: 'offset',\n        distance: beforeMatch[0].length,\n      });\n\n      return {\n        point,\n        range: point && Editor.range(editor, point, start),\n        input: beforeMatch[1],\n      };\n    },\n    [char, editor]\n  );\n\n  const hasWordsAfterStart = useCallback(\n    (start: Location) => {\n      const after = Editor.after(editor, start, { unit: 'line' });\n      const afterRange = after && Editor.range(editor, start, after);\n      const afterText = afterRange && Editor.string(editor, afterRange);\n\n      const expression = buildHasWordsAfterStartExpression(char);\n\n      const afterMatch = afterText?.match(/^([a-zA-Z_0-9]*\\b)/);\n      const afterMatchWithEnclosing =\n        char.suffix && afterText?.match(expression);\n\n      const match = afterMatchWithEnclosing ?? afterMatch;\n\n      if (!match) {\n        return null;\n      }\n\n      const point = Editor.after(editor, start, {\n        unit: 'offset',\n        distance: match[0].length,\n      });\n\n      return {\n        point,\n        range: point && Editor.range(editor, start, point),\n        input: match[1],\n      };\n    },\n    [char, editor]\n  );\n\n  const handleChange = useCallback(() => {\n    setSearchInput('');\n    setTarget(null);\n\n    const { selection } = editor;\n\n    if (selection && Range.isCollapsed(selection)) {\n      const [start] = Range.edges(selection);\n\n      const triggerCharPoint = isTriggerCharImmediatelyBeforeStart(start);\n      const enclosingCharPoint = isEnclosingCharImmediatelyAfterStart(start);\n      const middleBefore = hasWordsBeforeStart(start);\n      const middleAfter = hasWordsAfterStart(start);\n\n      if (triggerCharPoint && !enclosingCharPoint) {\n        setTarget(triggerCharPoint.range ?? null);\n        setSearchInput('');\n      } else if (triggerCharPoint && enclosingCharPoint) {\n        const combinedRange =\n          triggerCharPoint.range &&\n          enclosingCharPoint.range &&\n          Editor.range(\n            editor,\n            triggerCharPoint.range,\n            enclosingCharPoint.range\n          );\n\n        setTarget(combinedRange ?? null);\n        setSearchInput('');\n      } else if (middleBefore && !middleAfter) {\n        setTarget(middleBefore.range ?? null);\n        setSearchInput(middleBefore.input ?? '');\n      } else if (middleBefore && middleAfter) {\n        const combinedRange =\n          middleBefore.range &&\n          middleAfter.range &&\n          Editor.range(editor, middleBefore.range, middleAfter.range);\n        setTarget(combinedRange ?? null);\n        setSearchInput((middleBefore.input ?? '') + (middleAfter.input ?? ''));\n      }\n    }\n  }, [\n    editor,\n    hasWordsAfterStart,\n    hasWordsBeforeStart,\n    isEnclosingCharImmediatelyAfterStart,\n    isTriggerCharImmediatelyBeforeStart,\n  ]);\n\n  return {\n    handleChange,\n    target,\n    searchInput,\n  };\n};\n\nexport default useAutoComplete;\n","import React, { useMemo, useCallback } from 'react';\nimport { AvailableProperty, ListSummary } from 'types/models';\nimport { Transforms, Editor } from 'slate';\nimport { SelectMenu } from '@cko/primitives';\nimport RulesEditor from '../RulesEditor/RulesEditor';\nimport useAutoComplete, { TriggerChar } from '../RulesEditor/useAutoComplete';\nimport { useField } from 'formik';\nimport useSyntaxHighlighting from 'hooks/useSyntaxHighlighting';\nimport { useRulesBuilder } from '../RulesBuilderContext';\nimport { useRulesEditor } from '../RulesEditorContext';\n\nconst insertProperty = (editor: Editor, value: string, char: TriggerChar) => {\n  Transforms.insertText(editor, `${char.prefix}${value}${char.suffix ?? ''}`);\n  Transforms.insertText(editor, ' ');\n\n  Transforms.move(editor);\n};\n\ninterface WrappedProps {\n  name: string;\n  initialValue: string;\n  submitAndTestCount: number;\n}\n\nconst isList = (item: ListSummary | AvailableProperty): item is ListSummary =>\n  (item as ListSummary).alias !== undefined;\n\ntype FilterItems = AvailableProperty | ListSummary;\n\nconst RulesEditorContainer: React.FC<WrappedProps> = ({\n  name,\n  initialValue,\n  submitAndTestCount,\n}) => {\n  const { availableProperties, availableLists } = useRulesBuilder();\n\n  const { editor } = useRulesEditor();\n\n  const listAutocomplete = useAutoComplete(editor, {\n    prefix: '@',\n  });\n\n  const propertyAutocomplete = useAutoComplete(editor, {\n    prefix: ':',\n    suffix: ':',\n  });\n\n  const [, meta] = useField(name);\n\n  const hasErrors = submitAndTestCount > 0 && meta.error !== undefined;\n\n  const filterItems = useCallback(\n    (items: FilterItems[], text: string, key: keyof FilterItems) => {\n      return items.filter((property) =>\n        property[key].toLowerCase().includes(text.toLowerCase())\n      );\n    },\n    []\n  );\n\n  const filteredProperties = useMemo(() => {\n    if (propertyAutocomplete.target) {\n      if (propertyAutocomplete.searchInput !== null) {\n        return filterItems(\n          availableProperties,\n          propertyAutocomplete.searchInput,\n          'name'\n        );\n      }\n      return availableProperties;\n    } else if (listAutocomplete.target) {\n      if (listAutocomplete.searchInput !== null) {\n        return filterItems(\n          availableLists,\n          listAutocomplete.searchInput,\n          'alias' as keyof FilterItems\n        );\n      }\n      return availableLists;\n    }\n\n    return [];\n  }, [\n    availableLists,\n    availableProperties,\n    filterItems,\n    listAutocomplete.searchInput,\n    listAutocomplete.target,\n    propertyAutocomplete.searchInput,\n    propertyAutocomplete.target,\n  ]);\n\n  const { getLeafRenderer } = useSyntaxHighlighting();\n\n  const renderLeaf = useMemo(() => getLeafRenderer(availableProperties), [\n    availableProperties,\n    getLeafRenderer,\n  ]);\n\n  return (\n    <SelectMenu\n      initialSelectedItem={availableProperties[0]}\n      onChange={(property: AvailableProperty | ListSummary) => {\n        if (propertyAutocomplete.target && property && !isList(property)) {\n          Transforms.select(editor, propertyAutocomplete.target);\n          insertProperty(editor, property.name, { prefix: ':', suffix: ':' });\n        }\n        if (listAutocomplete.target && property && isList(property)) {\n          Transforms.select(editor, listAutocomplete.target);\n          insertProperty(editor, property.alias, { prefix: '@' });\n        }\n      }}\n    >\n      <RulesEditor\n        renderLeaf={renderLeaf}\n        onChange={() => {\n          propertyAutocomplete.handleChange();\n          listAutocomplete.handleChange();\n        }}\n        autoCompleteTarget={\n          propertyAutocomplete.target ?? listAutocomplete.target\n        }\n        autoCompleteItems={filteredProperties}\n        name={name}\n        initialValue={initialValue}\n        editor={editor}\n        hasErrors={hasErrors}\n      />\n    </SelectMenu>\n  );\n};\n\nexport default RulesEditorContainer;\n"],"sourceRoot":""}